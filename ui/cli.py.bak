#!/usr/bin/env python3
import os
import json
import argparse
import time
from pathlib import Path
from core import pipeline
from core import scrape_soundcloud
from config import CONFIG
import subprocess
import re

# Global state
QUEUE_LIST = []
VERBOSE_MODE = False
LOG_FILE = "/tmp/musicdowlder_verbose.log"
DOWNLOAD_IN_PROGRESS = False
STOP_AFTER_CURRENT = False
PROJECT_DIR = Path(__file__).resolve().parents[1]

# ------------------ Toggles ------------------
TOGGLE_KEYS = [
    "enable_youtube","enable_soundcloud","enable_duckduckgo",
    "restriction_checks","copyright_checks","analysis_only",
    "allow_downloads","allow_js","js_runtime_ready",
    "enable_js","max_results","download_dir","max_threads"
]

# ------------------ Utilities ------------------
def log_verbose(msg):
    if VERBOSE_MODE:
        timestamp = time.strftime("[%Y-%m-%d %H:%M:%S]")
        line = f"{timestamp} {msg}"
        print(line)
        with open(LOG_FILE, "a") as f:
            f.write(line + "\n")

def print_toggles():
    print("\n‚öôÔ∏è TOGGLES")
    for i, key in enumerate(TOGGLE_KEYS, 1):
        value = CONFIG.get(key)
        if key == "download_dir":
            value = CONFIG.get("download_dir", "")
        elif key == "max_threads":
            value = f"{CONFIG.get('max_threads',4)}/8"
        print(f"{i}) {key}: {value}")
    print("\nEnter number to toggle/modify (ENTER to continue)")

def toggle_option(number):
    if 1 <= number <= len(TOGGLE_KEYS):
        key = TOGGLE_KEYS[number-1]
        val = CONFIG.get(key)

        if isinstance(val, bool):
            CONFIG[key] = not val
            print(f"{key} set to {CONFIG[key]}")

        elif isinstance(val, int):
            if key == "max_threads":
                current = CONFIG.get("max_threads", 4)
                print(f"\nCurrent max threads: {current}/8")
                try:
                    new_val = input("Enter new max threads (1‚Äì8, ENTER to keep current): ").strip()
                    if new_val:
                        new_val = int(new_val)
                        if 1 <= new_val <= 8:
                            CONFIG[key] = new_val
                            print(f"‚úÖ max_threads set to {CONFIG[key]}")
                        else:
                            print("‚ùå Invalid value. Must be 1‚Äì8.")
                except ValueError:
                    print("‚ùå Invalid integer")
            else:
                try:
                    CONFIG[key] = int(input(f"Enter new value for {key} (current: {CONFIG[key]}): "))
                    print(f"{key} set to {CONFIG[key]}")
                except ValueError:
                    print("‚ùå Invalid integer")

        elif isinstance(val, str):
            if key == "download_dir":
                print(f"\nCurrent download directory:\n{CONFIG.get('download_dir','')}")
                new_path = input("Enter new download directory (ENTER to keep current): ").strip()
                if new_path:
                    os.makedirs(new_path, exist_ok=True)
                    CONFIG[key] = new_path
                    print(f"‚úÖ Download directory set to: {new_path}")
            else:
                new_val = input(f"Enter new value for {key} (current: {CONFIG[key]}): ")
                CONFIG[key] = new_val
                print(f"{key} set to {CONFIG[key]}")

        # Save config after any change
        from config import save_config
        save_config(CONFIG)

# ------------------ Core Handlers ------------------
def display_queue():
    if not QUEUE_LIST:
        print("üì≠ Queue is empty")
    else:
        print("üéµ Current Queue:")
        for idx, item in enumerate(QUEUE_LIST, 1):
            print(f"{idx}) {item['title']} ({item.get('source','unknown')})")

def parse_selection(selection_str, max_len):
    if not selection_str.strip():
        return list(range(max_len))
    selected = set()
    for part in selection_str.split(","):
        part = part.strip()
        if '-' in part:
            try:
                start, end = map(int, part.split('-'))
                start = max(1, start)
                end = min(max_len, end)
                for i in range(start, end+1):
                    selected.add(i-1)
            except ValueError:
                continue
        elif part.isdigit():
            i = int(part)
            if 1 <= i <= max_len:
                selected.add(i-1)
    return sorted(selected)

# ------------------ SoundCloud & YouTube ------------------
def handle_soundcloud(url):
    log_verbose(f"Detected SoundCloud URL: {url}")
    tracks = scrape_soundcloud.scrape_playlist(url)
    QUEUE_LIST.extend(tracks)
    log_verbose(f"Added {len(tracks)} tracks from SoundCloud to the queue")
    display_queue()
    sc_json = scrape_soundcloud.get_playlist_file_path()
    if os.path.exists(sc_json):
        os.remove(sc_json)
        log_verbose(f"Removed temporary file {sc_json}")

def fetch_youtube_playlist(playlist_url):
    playlist_url = re.sub(r"&si=.*$", "", playlist_url)
    tracks = []
    try:
        result = subprocess.run(
            ["yt-dlp", "--flat-playlist", "-J", playlist_url],
            capture_output=True, text=True, check=True
        )
        data = json.loads(result.stdout)
        for e in data.get("entries", []):
            vid_id = e.get("id")
            if not vid_id:
                continue
            url = f"https://www.youtube.com/watch?v={vid_id}"
            title = e.get("title") or url
            tracks.append({"title": title, "url": url, "source": "youtube"})
    except Exception as e:
        print(f"‚ùå Failed to fetch playlist: {e}")
    return tracks

# ------------------ Options Menu ------------------
def options_menu():
    while True:
        print_toggles()
        choice = input("\nSelect option (ENTER to return): ").strip()
        if choice == "":
            return
        if choice.isdigit():
            toggle_option(int(choice))
            continue
        print("‚ùå Invalid option")

# ------------------ Main Loop ------------------
def main_loop():
    global VERBOSE_MODE, STOP_AFTER_CURRENT
    parser = argparse.ArgumentParser()
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose logging")
    args = parser.parse_args()
    VERBOSE_MODE = args.verbose
    if VERBOSE_MODE:
        open(LOG_FILE,"w").close()
        log_verbose("üéµ MusicDowlder App Started (verbose mode)")

    while True:
        try:
            cmd = input(
                "Enter URL or command:\n"
                "-d download\n"
                "-c clear\n"
                "-e exit\n"
                "-o options\n"
                "-b backup\n> "
            ).strip()
        except KeyboardInterrupt:
            if input("Exit? (y/N): ").strip().lower() == "y":
                print("üëã Exiting...")
                break
            print()
            continue

        if not cmd:
            continue
        if cmd == "-o":
            options_menu()
            continue
        if cmd == "-c":
            if DOWNLOAD_IN_PROGRESS:
                STOP_AFTER_CURRENT = True
            QUEUE_LIST.clear()
            print("üßπ Queue cleared.")
            continue
        if cmd == "-e":
            if input("Exit? (y/N): ").strip().lower() == "y":
                print("üëã Exiting...")
                break
            continue
        if cmd == "-d":
            selected = parse_selection(input("Select tracks (ENTER=all): ").strip(), len(QUEUE_LIST))
            for item in [QUEUE_LIST[i] for i in selected]:
                pipeline.download_multi([item])
            continue
        if "soundcloud.com" in cmd:
            handle_soundcloud(cmd)
            continue
        if "youtube.com/playlist" in cmd:
            tracks = fetch_youtube_playlist(cmd)
            if tracks:
                QUEUE_LIST.extend(tracks)
                print(f"‚úÖ Added {len(tracks)} tracks from YouTube playlist")
                display_queue()
            else:
                print("‚ùå No results found.")
            continue
        results = pipeline.acquire(cmd)
        if results and results[0].get("url"):
            QUEUE_LIST.extend(results)
            display_queue()
        else:
            print("‚ùå No results found.")

if __name__ == "__main__":
    main_loop()
