#!/usr/bin/env python3
import os
import json
import argparse
import time
from core import pipeline
from core import scrape_soundcloud
from config import CONFIG

# Global state
QUEUE_LIST = []
VERBOSE_MODE = False
LOG_FILE = "/tmp/musicdowlder_verbose.log"
DOWNLOAD_IN_PROGRESS = False
STOP_AFTER_CURRENT = False

TOGGLE_KEYS = [
    "enable_youtube","enable_soundcloud","enable_duckduckgo",
    "restriction_checks","copyright_checks","analysis_only",
    "allow_downloads","allow_js","js_runtime_ready",
    "enable_js","max_results","download_dir"
]

# ------------------ Utilities ------------------

def log_verbose(msg):
    if VERBOSE_MODE:
        timestamp = time.strftime("[%Y-%m-%d %H:%M:%S]")
        line = f"{timestamp} {msg}"
        print(line)
        with open(LOG_FILE, "a") as f:
            f.write(line + "\n")

def print_toggles():
    print("\n‚öôÔ∏è TOGGLES")
    for i, key in enumerate(TOGGLE_KEYS, 1):
        print(f"{i}) {key}: {CONFIG[key]}")
    print("\nEnter number to toggle/modify (ENTER to continue)")

def toggle_option(number):
    if 1 <= number <= len(TOGGLE_KEYS):
        key = TOGGLE_KEYS[number-1]
        if isinstance(CONFIG[key], bool):
            CONFIG[key] = not CONFIG[key]
            print(f"{key} set to {CONFIG[key]}")
        elif isinstance(CONFIG[key], int):
            try:
                new_val = int(input(f"Enter new value for {key} (current: {CONFIG[key]}): "))
                CONFIG[key] = new_val
                print(f"{key} set to {CONFIG[key]}")
            except ValueError:
                print("Invalid input, must be integer")
        elif isinstance(CONFIG[key], str):
            new_val = input(f"Enter new value for {key} (current: {CONFIG[key]}): ")
            CONFIG[key] = new_val
            print(f"{key} set to {CONFIG[key]}")

def display_queue():
    if not QUEUE_LIST:
        print("üì≠ Queue is empty")
    else:
        print("üéµ Current Queue:")
        for idx, item in enumerate(QUEUE_LIST, 1):
            print(f"{idx}) {item['title']} ({item.get('source','unknown')})")

def parse_selection(selection_str, max_len):
    if not selection_str.strip():
        return list(range(max_len))
    selected = set()
    for part in selection_str.split(","):
        part = part.strip()
        if '-' in part:
            try:
                start, end = map(int, part.split('-'))
                start = max(1, start)
                end = min(max_len, end)
                for i in range(start, end+1):
                    selected.add(i-1)
            except ValueError:
                continue
        elif part.isdigit():
            i = int(part)
            if 1 <= i <= max_len:
                selected.add(i-1)
    return sorted(selected)

# ------------------ Core Handlers ------------------

def handle_soundcloud(url):
    log_verbose(f"Detected SoundCloud URL: {url}")
    tracks = scrape_soundcloud.scrape_playlist(url)
    QUEUE_LIST.extend(tracks)
    log_verbose(f"Added {len(tracks)} tracks from SoundCloud to the queue")
    display_queue()
    sc_json = scrape_soundcloud.get_playlist_file_path()
    if os.path.exists(sc_json):
        os.remove(sc_json)
        log_verbose(f"Removed temporary file {sc_json}")

def select_from_queue():
    if not QUEUE_LIST:
        print("Queue is empty! Nothing to select.")
        return []
    display_queue()
    sel = input("\nSelect numbers to download (comma/range, ENTER=all): ").strip()
    selected_indexes = parse_selection(sel, len(QUEUE_LIST))
    if not selected_indexes:
        print("‚ö†Ô∏è No valid selection. Going back.")
        return []
    choice = input(f"Download {len(selected_indexes)} selected items? (y/N): ").strip().lower()
    if choice != 'y':
        print("Selection skipped.")
        return []
    return selected_indexes

def download_selected(selected_indexes):
    global DOWNLOAD_IN_PROGRESS, STOP_AFTER_CURRENT
    if not selected_indexes:
        return

    DOWNLOAD_IN_PROGRESS = True
    items_to_download = [QUEUE_LIST[i] for i in selected_indexes]

    for item in items_to_download:
        if STOP_AFTER_CURRENT:
            break
        pipeline.download_multi([item])

    DOWNLOAD_IN_PROGRESS = False
    STOP_AFTER_CURRENT = False

    for i in sorted(selected_indexes, reverse=True):
        if i < len(QUEUE_LIST):
            del QUEUE_LIST[i]

def fetch_youtube_playlist(playlist_url):
    import subprocess, json, re
    playlist_url = re.sub(r"&si=.*$", "", playlist_url)
    try:
        result = subprocess.run(
            ["yt-dlp", "--flat-playlist", "-J", playlist_url],
            capture_output=True,
            text=True,
            check=True
        )
        data = json.loads(result.stdout)
        tracks = []
        for e in data.get("entries", []):
            url = "https://www.youtube.com/watch?v=" + e.get("id", "")
            title = e.get("title") or url
            tracks.append({"title": title, "url": url, "source": "youtube"})
        return tracks
    except Exception as e:
        print(f"‚ùå Failed to fetch playlist: {e}")
        return []

# ------------------ Options & Help ------------------

def options_menu():
    while True:
        print("\n‚öôÔ∏è OPTIONS\n")
        for i, key in enumerate(TOGGLE_KEYS, 1):
            print(f"{i}) {key}: {CONFIG[key]}")
        print("\nd) Change download directory")
        print("ENTER) Return to main menu")

        choice = input("\nSelect option: ").strip().lower()

        if choice == "":
            return
        if choice == "d":
            current = CONFIG.get("download_dir", "")
            print(f"\nCurrent download directory:\n{current}")
            new_path = input("Enter new download directory path (ENTER to cancel): ").strip()
            if not new_path:
                continue
            os.makedirs(new_path, exist_ok=True)
            CONFIG["download_dir"] = new_path
            print(f"‚úÖ Download directory set to: {new_path}")
            continue
        if choice.isdigit():
            toggle_option(int(choice))
            continue

        print("‚ùå Invalid option")

def print_help():
    print("""
üìñ MusicDowlder Help
Commands:
  -o   Open options / toggles menu
  -d   Download from current queue
  -c   Clear queue
  -e   Exit application
  -h   Show this help screen

Usage:
  ‚Ä¢ Paste URL to add tracks
  ‚Ä¢ Use -o to configure options
  ‚Ä¢ Use -d to download from queue
  ‚Ä¢ Use -c to clear queue
  ‚Ä¢ Use -e to exit cleanly
""")

# ------------------ Main Loop ------------------

def main_loop():
    global VERBOSE_MODE, STOP_AFTER_CURRENT
    parser = argparse.ArgumentParser()
    parser.add_argument("-verbos", action="store_true", help="Enable verbose logging")
    args = parser.parse_args()

    VERBOSE_MODE = args.verbos
    if VERBOSE_MODE:
        open(LOG_FILE,"w").close()
        log_verbose("üéµ MusicDowlder App Started (verbose mode)")

    while True:
        print_toggles()
        display_queue()

        try:
            url = input("\nEnter URL, -d to download, -c to clear, -e to exit, -o for options, -h for help: ").strip()
        except KeyboardInterrupt:
            print()
            confirm = input("Exit MusicDowlder? (y/N): ").strip().lower()
            if confirm == "y":
                print("üëã Exiting...")
                break
            continue

        if url.lower() == "-h":
            print_help()
            continue

        if url.lower() == "-o":
            options_menu()
            continue

        if url.lower() == "-c":
            if DOWNLOAD_IN_PROGRESS:
                print("\n‚ö†Ô∏è Downloads are currently running.")
                confirm = input("Stop after current downloads finish and clear queue? (y/N): ").strip().lower()
                if confirm != "y":
                    print("‚ñ∂Ô∏è Downloads will continue.\n")
                    continue
                print("üõë Will stop starting new downloads...")
                STOP_AFTER_CURRENT = True
                QUEUE_LIST.clear()
                print("üßπ Queue cleared. Returning to start.\n")
                continue
            QUEUE_LIST.clear()
            print("üßπ Queue cleared. Returning to start.\n")
            continue

        if url.lower() == "-e":
            confirm = input("Exit MusicDowlder? (y/N): ").strip().lower()
            if confirm == "y":
                print("üëã Exiting...")
                break
            continue

        if url.lower() == "-d":
            selected = select_from_queue()
            download_selected(selected)
            continue

        if "soundcloud.com" in url:
            handle_soundcloud(url)
        elif "youtube.com/playlist" in url:
            tracks = fetch_youtube_playlist(url)
            if tracks:
                QUEUE_LIST.extend(tracks)
                print(f"‚úÖ Added {len(tracks)} tracks from YouTube playlist to queue")
                display_queue()
            else:
                print("‚ùå No results found.")
        else:
            results = pipeline.acquire(url)
            if results and results[0].get("url"):
                QUEUE_LIST.extend(results)
                display_queue()
            else:
                print("‚ùå No results found.")

if __name__ == "__main__":
    main_loop()
