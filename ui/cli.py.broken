#!/usr/bin/env python3
import os
import json
import argparse
import time
from core import pipeline
from core import scrape_soundcloud
from config import CONFIG

QUEUE_LIST = []
VERBOSE_MODE = False
LOG_FILE = "/tmp/musicdowlder_verbose.log"

TOGGLE_KEYS = [
    "enable_youtube","enable_soundcloud","enable_duckduckgo",
    "restriction_checks","copyright_checks","analysis_only",
    "allow_downloads","allow_js","js_runtime_ready",
    "enable_js","max_results","download_dir"
]

def log_verbose(msg):
    if VERBOSE_MODE:
        timestamp = time.strftime("[%Y-%m-%d %H:%M:%S]")
        line = f"{timestamp} {msg}"
        print(line)
        with open(LOG_FILE, "a") as f:
            f.write(line + "\n")

def print_toggles():
    print("\n‚öôÔ∏è TOGGLES")
    for i,key in enumerate(TOGGLE_KEYS,1):
        print(f"{i}) {key}: {CONFIG[key]}")
    print("\nEnter number to toggle/modify (ENTER to continue)")

def toggle_option(number):
    if 1 <= number <= len(TOGGLE_KEYS):
        key = TOGGLE_KEYS[number-1]
        if isinstance(CONFIG[key], bool):
            CONFIG[key] = not CONFIG[key]
            print(f"{key} set to {CONFIG[key]}")
        elif isinstance(CONFIG[key], int):
            try:
                new_val = int(input(f"Enter new value for {key} (current: {CONFIG[key]}): "))
                CONFIG[key] = new_val
                print(f"{key} set to {CONFIG[key]}")
            except ValueError:
                print("Invalid input, must be integer")
        elif isinstance(CONFIG[key], str):
            new_val = input(f"Enter new value for {key} (current: {CONFIG[key]}): ")
            CONFIG[key] = new_val
            print(f"{key} set to {CONFIG[key]}")

def display_queue():
    if not QUEUE_LIST:
        print("üì≠ Queue is empty")
    else:
        print("üéµ Current Queue:")
        for idx,item in enumerate(QUEUE_LIST,1):
            print(f"{idx}) {item['title']} ({item.get('source','unknown')})")

def parse_selection(selection_str, max_len):
    if not selection_str.strip():
        return list(range(max_len))
    selected = set()
    for part in selection_str.split(","):
        part = part.strip()
        if '-' in part:
            try:
                start,end = map(int, part.split('-'))
                start = max(1,start)
                end = min(max_len,end)
                for i in range(start,end+1):
                    selected.add(i-1)
            except ValueError:
                continue
        elif part.isdigit():
            i = int(part)
            if 1 <= i <= max_len:
                selected.add(i-1)
    return sorted(selected)

def handle_soundcloud(url):
    log_verbose(f"Detected SoundCloud URL: {url}")
    tracks = scrape_soundcloud.scrape_playlist(url)
    QUEUE_LIST.extend(tracks)
    log_verbose(f"Added {len(tracks)} tracks from SoundCloud to the queue")
    display_queue()
    sc_json = scrape_soundcloud.get_playlist_file_path()
    if os.path.exists(sc_json):
        os.remove(sc_json)
        log_verbose(f"Removed temporary file {sc_json}")

def select_from_queue():
    if not QUEUE_LIST:
        print("Queue is empty! Nothing to select.")
        return []
    display_queue()
    sel = input("\nSelect numbers to download (comma/range, ENTER=all): ").strip()
    selected_indexes = parse_selection(sel, len(QUEUE_LIST))
    if not selected_indexes:
        print("‚ö†Ô∏è No valid selection. Going back.")
        return []
    choice = input(f"Download {len(selected_indexes)} selected items? (y/N): ").strip().lower()
    if choice != 'y':
        print("Selection skipped.")
        return []
    return selected_indexes

def download_selected(selected_indexes):
    if not selected_indexes:
        return
    items_to_download = [QUEUE_LIST[i] for i in selected_indexes]
    pipeline.download_multi(items_to_download)
    for i in sorted(selected_indexes,reverse=True):
        del QUEUE_LIST[i]

def fetch_youtube_playlist(playlist_url):
    """Fetch all video URLs and titles from a YouTube playlist using yt-dlp JSON."""
    import subprocess, json, re
    playlist_url = re.sub(r"&si=.*$", "", playlist_url)
    try:
        result = subprocess.run(
            ["yt-dlp", "--flat-playlist", "-J", playlist_url],
            capture_output=True,
            text=True,
            check=True
        )
        data = json.loads(result.stdout)
        tracks = []
        for e in data.get("entries", []):
            url = "https://www.youtube.com/watch?v=" + e.get("id", "")
            title = e.get("title") or url
            tracks.append({"title": title, "url": url, "source": "youtube"})
        return tracks
    except Exception as e:
        print(f"‚ùå Failed to fetch playlist: {e}")
        return []

def main_loop():
    global VERBOSE_MODE
    parser = argparse.ArgumentParser()
    parser.add_argument("-verbos", action="store_true", help="Enable verbose logging")
    args = parser.parse_args()
# --------- Command Block: Clear Queue (-c) ---------
if args.clear:
    print("üßπ Clearing download queue...")
    pipeline.clear_queue()   # Clear all pending downloads
    print("‚úÖ Queue cleared. Returning to start.
")
    continue  # Go back to the start of the CLI loop
# ----------------------------------------------------
    VERBOSE_MODE = args.verbos
    if VERBOSE_MODE:
        open(LOG_FILE,"w").close()
        log_verbose("üéµ MusicDowlder App Started (verbose mode)")

    while True:
        print_toggles()
        display_queue()
        try:
            url = input("\nEnter URL, -d to download, or 'exit' to quit: ").strip()
        except KeyboardInterrupt:
            print("\nExiting...")
            break

        if url.lower() == "exit":
            break
        elif url.lower() == "-d":
            selected = select_from_queue()
            download_selected(selected)
            continue

        if "soundcloud.com" in url:
            handle_soundcloud(url)
        elif "youtube.com/playlist" in url:
            tracks = fetch_youtube_playlist(url)
            if tracks:
                QUEUE_LIST.extend(tracks)
                print(f"‚úÖ Added {len(tracks)} tracks from YouTube playlist to queue")
                display_queue()
            else:
                print("‚ùå No results found.")
        else:
            results = pipeline.acquire(url)
            if results and results[0].get("url"):
                QUEUE_LIST.extend(results)
                display_queue()
            else:
                print("‚ùå No results found.")

if __name__ == "__main__":
    main_loop()
