#!/bin/bash
cd ~/musicdowlder || exit 1

# -----------------------------
# 1ï¸âƒ£ Ensure core and ui packages exist
# -----------------------------
mkdir -p core ui
touch core/__init__.py ui/__init__.py

# -----------------------------
# 2ï¸âƒ£ Core: pipeline.py
# -----------------------------
cat > core/pipeline.py << 'EOF'
import subprocess
import json
import os
import requests
from bs4 import BeautifulSoup
from config import CONFIG

DOWNLOAD_DIR = CONFIG.get("download_dir", "downloads")
os.makedirs(DOWNLOAD_DIR, exist_ok=True)

# ---------------------------
# YouTube / SoundCloud search using yt-dlp
# ---------------------------
def yt_dlp_search(query, source="youtube", limit=5):
    if source == "youtube" and not CONFIG["enable_youtube"]:
        return []
    if source == "soundcloud" and not CONFIG["enable_soundcloud"]:
        return []

    cmd = [
        "yt-dlp",
        f"{source}search{limit}:{query}",
        "--dump-json",
        "--skip-download",
        "--no-playlist"
    ]
    proc = subprocess.run(cmd, capture_output=True, text=True)
    results = []
    for line in proc.stdout.splitlines():
        try:
            data = json.loads(line)
            results.append({
                "title": data.get("title"),
                "url": data.get("webpage_url"),
                "source": data.get("extractor"),
                "duration": data.get("duration")
            })
        except json.JSONDecodeError:
            continue
    return results

# ---------------------------
# DuckDuckGo fallback
# ---------------------------
def duckduckgo_search(query, max_results=5):
    if not CONFIG["enable_duckduckgo"]:
        return []
    search_url = f"https://duckduckgo.com/html/?q={query.replace(' ', '+')}+mp3"
    r = requests.get(search_url, headers={"User-Agent": "Mozilla/5.0"})
    soup = BeautifulSoup(r.text, "html.parser")
    results = []
    for a in soup.select("a[href$='.mp3']")[:max_results]:
        results.append({
            "title": os.path.basename(a['href']),
            "url": a['href'],
            "source": "duckduckgo",
            "duration": None
        })
    return results

# ---------------------------
# Playlist extraction
# ---------------------------
def yt_dlp_playlist(url):
    cmd = [
        "yt-dlp",
        "--dump-json",
        "--flat-playlist",
        url
    ]
    proc = subprocess.run(cmd, capture_output=True, text=True)
    tracks = []
    for line in proc.stdout.splitlines():
        try:
            data = json.loads(line)
            tracks.append({
                "title": data.get("title"),
                "url": data.get("url") if "url" in data else data.get("webpage_url"),
                "source": "playlist"
            })
        except json.JSONDecodeError:
            continue
    return tracks

# ---------------------------
# Acquire tracks from all sources
# ---------------------------
def acquire(query):
    results = []
    results += yt_dlp_search(query, "youtube", CONFIG["max_results"])
    results += yt_dlp_search(query, "soundcloud", CONFIG["max_results"])
    results += duckduckgo_search(query, CONFIG["max_results"])
    if not results:
        return [{"title": "No results found", "url": None, "source": "none"}]
    return results

# ---------------------------
# Download a track
# ---------------------------
def download(item_or_url):
    if CONFIG["analysis_only"]:
        return f"Analysis-only mode: skipping download"
    if not CONFIG["allow_downloads"]:
        return f"Downloads disabled by toggle"

    if isinstance(item_or_url, dict):
        url = item_or_url["url"]
        title = item_or_url.get("title", "track")
    else:
        url = item_or_url
        title = "track"

    cmd = [
        "yt-dlp",
        "-x",
        "--audio-format", "mp3",
        "--audio-quality", "0",
        "-o", os.path.join(DOWNLOAD_DIR, "%(title)s.%(ext)s"),
        url
    ]
    subprocess.run(cmd)
    return f"Downloaded: {title}"

# ---------------------------
# Process queue
# ---------------------------
def process_queue(queue):
    for item in queue:
        url = item.get("url") or item
        if "playlist" in url:
            playlist_tracks = yt_dlp_playlist(url)
            for track in playlist_tracks:
                print(download(track))
        else:
            print(download(item))
EOF

# -----------------------------
# 3ï¸âƒ£ UI CLI
# -----------------------------
cat > ui/cli.py << 'EOF'
import os
from core.pipeline import acquire, download, process_queue, yt_dlp_playlist
from config import CONFIG

queue = []

TOGGLE_KEYS = [
    "enable_youtube",
    "enable_soundcloud",
    "enable_duckduckgo",
    "restriction_checks",
    "copyright_checks",
    "analysis_only",
    "allow_downloads",
    "allow_js",
    "js_runtime_ready",
    "enable_js",
    "max_results",
    "download_dir"
]

def print_toggles():
    print("\nâš™ï¸ TOGGLES")
    for i, key in enumerate(TOGGLE_KEYS, 1):
        print(f"{i}) {key}: {CONFIG[key]}")
    print("\nEnter number to toggle (ENTER to continue)")

def toggle_option(number):
    if 1 <= number <= len(TOGGLE_KEYS):
        key = TOGGLE_KEYS[number - 1]
        if isinstance(CONFIG[key], bool):
            CONFIG[key] = not CONFIG[key]
            print(f"{key} set to {CONFIG[key]}")
        elif isinstance(CONFIG[key], int):
            try:
                new_val = int(input(f"Enter new value for {key} (current: {CONFIG[key]}): "))
                CONFIG[key] = new_val
                print(f"{key} set to {CONFIG[key]}")
            except ValueError:
                print("Invalid input, must be an integer")
        elif isinstance(CONFIG[key], str):
            new_val = input(f"Enter new value for {key} (current: {CONFIG[key]}): ")
            CONFIG[key] = new_val
            print(f"{key} set to {CONFIG[key]}")

def add_to_queue_from_search(results):
    print("\nRESULTS:")
    for idx, r in enumerate(results, 1):
        print(f"{idx}) {r['title']} ({r['source']})")
    sel = input("\nSelect number to add to queue (ENTER skip): ")
    if sel.isdigit():
        idx = int(sel) - 1
        if 0 <= idx < len(results):
            queue.append(results[idx])
            print(f"Added to queue: {results[idx]['title']}")

def add_to_queue_from_playlist(url):
    tracks = yt_dlp_playlist(url)
    for t in tracks:
        queue.append(t)
        print(f"Added to queue: {t['title']}")

def run_cli():
    print("ðŸŽµ MusicFinder CLI â€” Multi-pane interface with live toggles and playlist support")
    while True:
        print_toggles()
        choice = input("> ").strip()
        if choice.isdigit():
            toggle_option(int(choice))
            continue

        query = choice
        if query.lower() == "q":
            print("Exiting MusicFinder CLIâ€¦")
            break
        if query.lower() == "-d":
            if not queue:
                print("Queue is empty!")
            else:
                print("Processing queueâ€¦")
                process_queue(queue)
                queue.clear()
            continue

        # Playlist URL auto-detection
        if query.startswith("http") and ("playlist" in query or "list=" in query):
            add_to_queue_from_playlist(query)
            continue

        # Otherwise treat as search
        results = acquire(query)
        if not results or results[0].get("url") is None:
            print("âŒ No results found.")
        else:
            add_to_queue_from_search(results)

        print("\nQueue:")
        for idx, item in enumerate(queue, 1):
            print(f"{idx}) {item.get('title')}")

if __name__ == "__main__":
    run_cli()
EOF

# -----------------------------
# 4ï¸âƒ£ startapp
# -----------------------------
cat > startapp << 'EOF'
#!/bin/bash
cd "$(dirname "$0")"
export PYTHONPATH="$(pwd)"
python3 ui/cli.py
EOF

chmod +x startapp
chmod +x ui/cli.py

echo "âœ… MusicFinder fully rebuilt. Run ./startapp to launch CLI."
