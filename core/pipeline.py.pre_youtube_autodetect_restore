import subprocess
import json
import os
import requests
import threading
from queue import Queue
from config import CONFIG
from bs4 import BeautifulSoup
from tqdm import tqdm

DOWNLOAD_DIR = CONFIG.get("download_dir", "downloads")
os.makedirs(DOWNLOAD_DIR, exist_ok=True)

# ---------------------------
# Search (unchanged)
# ---------------------------
def yt_dlp_search(query, source="youtube", limit=5):
    if source == "youtube" and not CONFIG["enable_youtube"]:
        return []
    if source == "soundcloud" and not CONFIG["enable_soundcloud"]:
        return []

    cmd = [
        "yt-dlp",
        f"{source}search{limit}:{query}",
        "--dump-json",
        "--skip-download",
        "--no-playlist"
    ]
    proc = subprocess.run(cmd, capture_output=True, text=True)
    results = []
    for line in proc.stdout.splitlines():
        try:
            data = json.loads(line)
            results.append({
                "title": data.get("title"),
                "url": data.get("webpage_url"),
                "source": data.get("extractor"),
                "duration": data.get("duration")
            })
        except json.JSONDecodeError:
            continue
    return results

def duckduckgo_search(query, max_results=5):
    if not CONFIG["enable_duckduckgo"]:
        return []
    search_url = f"https://duckduckgo.com/html/?q={query.replace(' ', '+')}+mp3"
    r = requests.get(search_url, headers={"User-Agent": "Mozilla/5.0"})
    soup = BeautifulSoup(r.text, "html.parser")
    results = []
    for a in soup.select("a[href$='.mp3']")[:max_results]:
        results.append({
            "title": os.path.basename(a['href']),
            "url": a['href'],
            "source": "duckduckgo",
            "duration": None
        })
    return results

def yt_dlp_playlist(url):
    cmd = ["yt-dlp", "--dump-json", "--flat-playlist", url]
    proc = subprocess.run(cmd, capture_output=True, text=True)
    tracks = []
    for line in proc.stdout.splitlines():
        try:
            data = json.loads(line)
            tracks.append({
                "title": data.get("title"),
                "url": data.get("url") or data.get("webpage_url"),
                "source": "playlist"
            })
        except json.JSONDecodeError:
            continue
    return tracks

def acquire(query):
    results = []
    results += yt_dlp_search(query, "youtube", CONFIG["max_results"])
    results += yt_dlp_search(query, "soundcloud", CONFIG["max_results"])
    results += duckduckgo_search(query, CONFIG["max_results"])
    if not results:
        return [{"title": "No results found", "url": None, "source": "none"}]
    return results

# ---------------------------
# Download with persistent progress bars
# ---------------------------
def download_worker(queue_items, stats, position_lock):
    while True:
        try:
            item = queue_items.get_nowait()
        except:
            return

        title = item.get("title", "track")
        url = item.get("url")

        if CONFIG["analysis_only"] or not CONFIG["allow_downloads"]:
            with stats["lock"]:
                stats["skipped"] += 1
            queue_items.task_done()
            continue

        with position_lock:
            pos = stats["bar_index"]
            stats["bar_index"] += 1

        bar = tqdm(
            total=100,
            desc=title[:40],
            position=pos,
            leave=True
        )

        try:
            cmd = [
                "yt-dlp",
                "-x",
                "--audio-format", "mp3",
                "--audio-quality", "0",
                "--newline",
                "-o", os.path.join(DOWNLOAD_DIR, "%(title)s.%(ext)s"),
                url
            ]

            proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)

            for line in proc.stdout:
                if "%" in line:
                    try:
                        pct = float(line.split("%")[0].split()[-1])
                        bar.n = pct
                        bar.refresh()
                    except:
                        pass

            proc.wait()
            bar.n = 100
            bar.refresh()

            with stats["lock"]:
                stats["success"] += 1

        except:
            with stats["lock"]:
                stats["failed"] += 1
        finally:
            bar.close()
            queue_items.task_done()

def download_multi(queue_list, max_threads=4):
    queue_items = Queue()
    for item in queue_list:
        queue_items.put(item)

    stats = {
        "success": 0,
        "failed": 0,
        "skipped": 0,
        "bar_index": 0,
        "lock": threading.Lock()
    }

    position_lock = threading.Lock()
    threads = []

    for _ in range(min(max_threads, queue_items.qsize())):
        t = threading.Thread(
            target=download_worker,
            args=(queue_items, stats, position_lock),
            daemon=True
        )
        t.start()
        threads.append(t)

    queue_items.join()

    print(
        f"\n✅ Completed: {stats['success']}/{len(queue_list)} "
        f"· ❌ Failed: {stats['failed']} · ⏭ Skipped: {stats['skipped']}"
    )

    return stats
